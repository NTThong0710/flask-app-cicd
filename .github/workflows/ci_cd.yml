name: Flask App CI/CD with GitHub Packages & ECR Artifact Management

on:
  push:
    branches: [ master, develop ]
    tags: [ 'v*' ]
  pull_request:
    branches: [ master ]
  workflow_dispatch:

env:
  # GitHub Packages
  GITHUB_REGISTRY: ghcr.io
  GITHUB_IMAGE_NAME: ntthong0710/flask-app-cicd
  
  # AWS ECR
  AWS_REGION: ap-southeast-1
  ECR_REPOSITORY: flask-app
  
  # Deployment
  EC2_IP: 13.229.126.89

jobs:
  code-verification:
    name: Code Quality & Security Check
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.10'
        
    - name: Install code quality tools
      run: |
        python -m pip install --upgrade pip
        pip install flake8 black bandit safety mypy
        pip install -r requirements.txt || echo "No requirements.txt found"
        
    - name: Python syntax check
      run: |
        echo "🔍 Checking Python syntax..."
        python -m py_compile app.py
        find . -name "*.py" -exec python -m py_compile {} \;
        echo "✅ Syntax check passed"
        
    - name: Code style check (PEP8)
      run: |
        echo "🎨 Checking code style with flake8..."
        flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics --exclude=venv,env
        flake8 . --count --max-complexity=10 --max-line-length=120 --statistics --exclude=venv,env || true
        echo "✅ Code style check completed"
        
    - name: Security vulnerability scan
      run: |
        echo "🔒 Scanning for security vulnerabilities..."
        bandit -r . -f json -o bandit-report.json || true
        bandit -r . --severity-level medium || echo "⚠️ Security warnings found"
        
    - name: Dependency security check
      run: |
        echo "🛡️ Checking dependencies for known vulnerabilities..."
        safety check || echo "⚠️ Dependency security warnings found"

  test:
    name: Unit Tests
    runs-on: ubuntu-latest
    needs: code-verification
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.10'
        
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt || echo "No requirements.txt found"
        pip install pytest pytest-cov
        
    - name: Run unit tests
      run: |
        if [ -f "test_app.py" ] || [ -d "tests/" ]; then
          echo "🧪 Running unit tests..."
          pytest --verbose --cov=. --cov-report=term --cov-report=xml
          echo "✅ Tests completed"
        else
          echo "📝 Creating basic test..."
          echo "
        import requests
        import subprocess
        import time

        def test_app_starts():
            '''Test that the app can start without errors'''
            try:
                import app
                assert True
            except Exception as e:
                assert False, f'App failed to import: {e}'

        def test_basic_functionality():
            '''Basic functionality test'''
            import app
            assert hasattr(app, 'app'), 'Flask app object should exist'
                  " > basic_test.py
                  pytest basic_test.py --verbose
                fi

  sonarcloud:
    name: SonarCloud analysis
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'
      
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install pytest pytest-cov
          if [ -f requirements.txt ]; then pip install -r requirements.txt; fi
      
      - name: Run tests with coverage
        run: |
          pytest --cov=. --cov-report=xml
      
      - name: SonarCloud Scan
        uses: SonarSource/sonarcloud-github-action@master
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}

  # ===========================================
  # DUAL ARTIFACT MANAGEMENT - GITHUB PACKAGES
  # ===========================================
  
  build-and-publish-github:
    name: Build & Publish to GitHub Packages
    needs: [code-verification, test, sonarcloud]
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      id-token: write
      attestations: write
    outputs:
      image-digest: ${{ steps.build.outputs.digest }}
      image-tags: ${{ steps.meta.outputs.tags }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Extract metadata for Docker
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.GITHUB_REGISTRY }}/${{ env.GITHUB_IMAGE_NAME }}
        tags: |
          type=ref,event=tag
          type=ref,event=branch
          type=sha,prefix=sha-
          type=raw,value=latest,enable={{is_default_branch}}
        labels: |
          org.opencontainers.image.title=Flask Application
          org.opencontainers.image.description=Production Flask App with CI/CD
          org.opencontainers.image.vendor=${{ github.repository_owner }}
          org.opencontainers.image.version=${{ github.ref_name }}
          maintainer=${{ github.actor }}
          build.number=${{ github.run_number }}
          build.url=${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
    
    - name: Log in to GitHub Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.GITHUB_REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
    
    - name: Build and push to GitHub Packages
      id: build
      uses: docker/build-push-action@v5
      with:
        context: .
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        platforms: linux/amd64
        cache-from: type=gha
        cache-to: type=gha,mode=max
        provenance: true
        sbom: true
    
    - name: Generate artifact attestation
      uses: actions/attest-build-provenance@v1
      with:
        subject-name: ${{ env.GITHUB_REGISTRY }}/${{ env.GITHUB_IMAGE_NAME }}
        subject-digest: ${{ steps.build.outputs.digest }}
        push-to-registry: true

  # ===========================================
  # DUAL ARTIFACT MANAGEMENT - AWS ECR
  # ===========================================
  
  build-and-publish-ecr:
    name: Build & Push to AWS ECR
    needs: [code-verification, test, sonarcloud]
    runs-on: ubuntu-latest
    outputs:
      ecr-image-uri: ${{ steps.outputs.outputs.image-uri }}
      ecr-image-tag: ${{ steps.outputs.outputs.image-tag }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2
    
    - name: Determine image tag
      id: tag
      run: |
        # Determine image tag based on git reference
        if [[ $GITHUB_REF == refs/tags/* ]]; then
          IMAGE_TAG=${GITHUB_REF#refs/tags/}
        elif [[ $GITHUB_REF == refs/heads/master ]]; then
          IMAGE_TAG="latest"
        elif [[ $GITHUB_REF == refs/heads/* ]]; then
          BRANCH_NAME=${GITHUB_REF#refs/heads/}
          IMAGE_TAG="${BRANCH_NAME}"
        else
          IMAGE_TAG="sha-${GITHUB_SHA::8}"
        fi
        
        echo "image-tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
        echo "🏷️ Determined image tag: $IMAGE_TAG"
    
    - name: Build image metadata
      id: meta
      run: |
        ECR_REGISTRY=${{ steps.login-ecr.outputs.registry }}
        ECR_REPOSITORY=${{ env.ECR_REPOSITORY }}
        IMAGE_TAG=${{ steps.tag.outputs.image-tag }}
        
        # Build full image URI
        IMAGE_URI="$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG"
        
        # Create all tags for this build
        TAGS="$IMAGE_URI"
        
        # Add latest tag for master branch and version tags
        if [[ "$IMAGE_TAG" == "latest" ]] || [[ "$IMAGE_TAG" =~ ^v[0-9] ]]; then
          TAGS="$TAGS,$ECR_REGISTRY/$ECR_REPOSITORY:latest"
        fi
        
        # Add build number tag
        TAGS="$TAGS,$ECR_REGISTRY/$ECR_REPOSITORY:build-${{ github.run_number }}"
        
        echo "tags=$TAGS" >> $GITHUB_OUTPUT
        echo "image-uri=$IMAGE_URI" >> $GITHUB_OUTPUT
        echo "registry=$ECR_REGISTRY" >> $GITHUB_OUTPUT
        echo "repository=$ECR_REPOSITORY" >> $GITHUB_OUTPUT
        
        echo "📋 Build metadata:"
        echo "  Primary Image URI: $IMAGE_URI"
        echo "  All Tags: $TAGS"
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
    
    - name: Build and push to ECR
      id: build-ecr
      uses: docker/build-push-action@v5
      with:
        context: .
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: |
          org.opencontainers.image.title=Flask Application
          org.opencontainers.image.description=Production Flask App with CI/CD
          org.opencontainers.image.vendor=${{ github.repository_owner }}
          org.opencontainers.image.version=${{ github.ref_name }}
          maintainer=${{ github.actor }}
          build.number=${{ github.run_number }}
          build.url=${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          deployment.target=aws-ecr
        platforms: linux/amd64
        cache-from: type=gha
        cache-to: type=gha,mode=max
    
    - name: Set job outputs
      id: outputs
      run: |
        IMAGE_TAG=${{ steps.tag.outputs.image-tag }}
        IMAGE_URI=${{ steps.meta.outputs.image-uri }}
        
        echo "image-uri=$IMAGE_URI" >> $GITHUB_OUTPUT
        echo "image-tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
        
        echo "✅ Job outputs set:"
        echo "  Image URI: $IMAGE_URI"
        echo "  Image Tag: $IMAGE_TAG"

  # ===========================================
  # ECR SECURITY SCANNING
  # ===========================================
  
  ecr-security-scan:
    name: ECR Security Scan
    needs: build-and-publish-ecr
    runs-on: ubuntu-latest
    
    steps:
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Debug ECR outputs
      run: |
        echo "🔍 Debug ECR Build Outputs:"
        echo "ECR Image URI: ${{ needs.build-and-publish-ecr.outputs.ecr-image-uri }}"
        echo "ECR Image Tag: ${{ needs.build-and-publish-ecr.outputs.ecr-image-tag }}"
        
        # Validate tag is not empty
        if [ -z "${{ needs.build-and-publish-ecr.outputs.ecr-image-tag }}" ]; then
          echo "❌ Error: ECR image tag is empty!"
          exit 1
        fi
    
    - name: Start ECR image scan
      run: |
        echo "🔍 Starting ECR security scan..."
        IMAGE_TAG="${{ needs.build-and-publish-ecr.outputs.ecr-image-tag }}"
        
        echo "📋 Scan Parameters:"
        echo "Repository: ${{ env.ECR_REPOSITORY }}"
        echo "Image Tag: $IMAGE_TAG"
        echo "Region: ${{ env.AWS_REGION }}"
        
        # Start image scan with enhanced error handling
        if aws ecr start-image-scan \
          --repository-name ${{ env.ECR_REPOSITORY }} \
          --image-id imageTag=$IMAGE_TAG \
          --region ${{ env.AWS_REGION }}; then
          echo "✅ Image scan started successfully"
          echo "SCAN_STARTED=true" >> $GITHUB_ENV
        else
          echo "⚠️ Failed to start image scan (possibly unsupported image type or scan already in progress)"
          echo "SCAN_STARTED=false" >> $GITHUB_ENV
        fi
    
    - name: Get scan results
      if: env.SCAN_STARTED == 'true'
      run: |
        IMAGE_TAG="${{ needs.build-and-publish-ecr.outputs.ecr-image-tag }}"
        
        echo "⏳ Waiting for scan to complete..."
        sleep 90
        
        # Get scan results with retry logic
        for i in {1..5}; do
          echo "📊 Attempt $i: Getting scan results..."
          
          if SCAN_RESULTS=$(aws ecr describe-image-scan-findings \
            --repository-name ${{ env.ECR_REPOSITORY }} \
            --image-id imageTag=$IMAGE_TAG \
            --region ${{ env.AWS_REGION }} \
            --output json 2>/dev/null); then
            
            echo "✅ Scan results retrieved successfully"
            
            # Parse and display results
            SCAN_STATUS=$(echo "$SCAN_RESULTS" | jq -r '.imageScanStatus.status')
            echo "📋 Scan Status: $SCAN_STATUS"
            
            if [ "$SCAN_STATUS" == "COMPLETE" ]; then
              echo "📊 Vulnerability Summary:"
              echo "$SCAN_RESULTS" | jq '.imageScanFindingsSummary'
              
              # Check for critical vulnerabilities
              CRITICAL_COUNT=$(echo "$SCAN_RESULTS" | jq -r '.imageScanFindingsSummary.findingCounts.CRITICAL // 0')
              HIGH_COUNT=$(echo "$SCAN_RESULTS" | jq -r '.imageScanFindingsSummary.findingCounts.HIGH // 0')
              MEDIUM_COUNT=$(echo "$SCAN_RESULTS" | jq -r '.imageScanFindingsSummary.findingCounts.MEDIUM // 0')
              
              echo "🚨 Critical vulnerabilities: $CRITICAL_COUNT"
              echo "⚠️ High vulnerabilities: $HIGH_COUNT"
              echo "📝 Medium vulnerabilities: $MEDIUM_COUNT"
              
              if [ "$CRITICAL_COUNT" -gt 0 ]; then
                echo "❌ Critical vulnerabilities found! Review recommended."
                # List some critical findings
                echo "$SCAN_RESULTS" | jq -r '.imageScanFindings[] | select(.severity == "CRITICAL") | "- \(.name): \(.description)"' | head -5
              else
                echo "✅ No critical vulnerabilities found"
              fi
              
              break
            else
              echo "⏳ Scan status: $SCAN_STATUS, waiting..."
              sleep 30
            fi
          else
            echo "⏳ Scan results not ready yet, waiting 30s..."
            sleep 30
          fi
        done
    
    - name: Alternative security check
      if: env.SCAN_STARTED == 'false'
      run: |
        echo "🔍 Running alternative security check with Trivy..."
        
        # Install Trivy
        sudo apt-get update
        sudo apt-get install wget apt-transport-https gnupg lsb-release
        wget -qO - https://aquasecurity.github.io/trivy-repo/deb/public.key | sudo apt-key add -
        echo "deb https://aquasecurity.github.io/trivy-repo/deb $(lsb_release -sc) main" | sudo tee -a /etc/apt/sources.list.d/trivy.list
        sudo apt-get update
        sudo apt-get install trivy
        
        # Login to ECR
        aws ecr get-login-password --region ${{ env.AWS_REGION }} | docker login --username AWS --password-stdin ${{ needs.build-and-publish-ecr.outputs.ecr-image-uri-base }}
        
        # Scan with Trivy
        IMAGE_URI="${{ needs.build-and-publish-ecr.outputs.ecr-image-uri }}"
        echo "🔍 Scanning $IMAGE_URI with Trivy..."
        
        trivy image --severity HIGH,CRITICAL --format table $IMAGE_URI || echo "⚠️ Trivy scan completed with warnings"

  # ===========================================
  # ARTIFACT PROMOTION & DEPLOYMENT
  # ===========================================
  
  promote-and-deploy:
    name: Deploy from ECR to EC2
    needs: [build-and-publish-ecr, ecr-security-scan]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/master' || startsWith(github.ref, 'refs/tags/v')
    environment: production
    
    steps:
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Deploy to EC2 from ECR
      run: |
        echo "🚀 Deploying from ECR to Production EC2..."
        
        # Install SSH client
        which ssh || (apt-get update && apt-get install -y openssh-client)
        
        # Setup SSH key
        mkdir -p ~/.ssh
        echo "${{ secrets.EC2_SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
        chmod 600 ~/.ssh/id_rsa
        
        # Add EC2 to known_hosts
        ssh-keyscan -H ${{ env.EC2_IP }} >> ~/.ssh/known_hosts
        
        # Get ECR image URI
        ECR_IMAGE_URI="${{ needs.build-and-publish-ecr.outputs.ecr-image-uri }}"
        
        echo "📦 Deploying image: $ECR_IMAGE_URI"
        
        # Deploy to EC2
        ssh -i ~/.ssh/id_rsa ec2-user@${{ env.EC2_IP }} << EOF
          # Configure AWS CLI on EC2 (if not already configured)
          export AWS_DEFAULT_REGION=${{ env.AWS_REGION }}
          
          # Login to ECR
          aws ecr get-login-password --region ${{ env.AWS_REGION }} | docker login --username AWS --password-stdin ${{ needs.build-and-publish-ecr.outputs.ecr-image-uri-base }}
          
          echo "📦 Pulling image from ECR: $ECR_IMAGE_URI"
          docker pull $ECR_IMAGE_URI
          
          echo "💾 Creating backup of current container"
          docker tag flask-app:current flask-app:backup-\$(date +%Y%m%d-%H%M%S) 2>/dev/null || true
          
          echo "🔄 Updating application..."
          docker stop flask-app 2>/dev/null || true
          docker rm flask-app 2>/dev/null || true
          
          echo "🆕 Starting new container from ECR..."
          docker run -d \
            --name flask-app \
            --restart unless-stopped \
            -p 5000:5000 \
            --label "version=${{ github.ref_name }}" \
            --label "build.number=${{ github.run_number }}" \
            --label "deployed.at=\$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
            --label "source=aws-ecr" \
            $ECR_IMAGE_URI
          
          # Health check
          echo "🏥 Performing health check..."
          sleep 15
          
          if curl -f http://localhost:5000/health 2>/dev/null || curl -f http://localhost:5000/ 2>/dev/null; then
            echo "✅ Health check passed"
            docker tag $ECR_IMAGE_URI flask-app:current
            
            # Cleanup old backup images (keep last 3)
            docker images --format "table {{.Repository}}:{{.Tag}}\t{{.CreatedAt}}" | grep flask-app:backup | tail -n +4 | cut -f1 | xargs -r docker rmi || true
          else
            echo "❌ Health check failed, rolling back..."
            docker stop flask-app 2>/dev/null || true
            docker rm flask-app 2>/dev/null || true
            
            # Rollback to backup if exists
            BACKUP_IMAGE=\$(docker images --format "{{.Repository}}:{{.Tag}}" flask-app:backup-* | head -1)
            if [ ! -z "\$BACKUP_IMAGE" ]; then
              docker run -d --name flask-app --restart unless-stopped -p 5000:5000 \$BACKUP_IMAGE
              echo "🔙 Rolled back to: \$BACKUP_IMAGE"
            fi
            exit 1
          fi
          
          echo "🧹 Cleaning up unused images..."
          docker image prune -f
          
          echo "🎉 ECR Deployment completed successfully!"
          echo "📍 Application URL: http://${{ env.EC2_IP }}:5000"
          echo "🏷️ Deployed Image: $ECR_IMAGE_URI"
        EOF

  # ===========================================
  # ARTIFACT MANAGEMENT REPORTING
  # ===========================================
  
  artifact-report:
    name: Generate Dual Artifact Management Report
    needs: [build-and-publish-github, build-and-publish-ecr, ecr-security-scan, promote-and-deploy]
    runs-on: ubuntu-latest
    if: always()
    permissions:
      packages: read
    
    steps:
    - name: Generate Comprehensive Artifact Report
      run: |
        echo "# 📋 Dual Artifact Management Report" > artifact-report.md
        echo "" >> artifact-report.md
        echo "**Build Information:**" >> artifact-report.md
        echo "- Build Number: ${{ github.run_number }}" >> artifact-report.md
        echo "- Git Reference: ${{ github.ref }}" >> artifact-report.md
        echo "- Commit SHA: ${{ github.sha }}" >> artifact-report.md
        echo "- Build Time: $(date -u)" >> artifact-report.md
        echo "" >> artifact-report.md
        
        echo "## 📦 GitHub Packages Artifacts" >> artifact-report.md
        echo '```' >> artifact-report.md
        echo '${{ needs.build-and-publish-github.outputs.image-tags }}' >> artifact-report.md
        echo '```' >> artifact-report.md
        echo "" >> artifact-report.md
        
        echo "## 🏗️ AWS ECR Artifacts" >> artifact-report.md
        echo "- **ECR Image URI:** \`${{ needs.build-and-publish-ecr.outputs.ecr-image-uri }}\`" >> artifact-report.md
        echo "- **ECR Image Tag:** \`${{ needs.build-and-publish-ecr.outputs.ecr-image-tag }}\`" >> artifact-report.md
        echo "" >> artifact-report.md
        
        echo "## 📊 Pipeline Results" >> artifact-report.md
        echo "- **GitHub Packages Build:** ${{ needs.build-and-publish-github.result }}" >> artifact-report.md
        echo "- **ECR Build:** ${{ needs.build-and-publish-ecr.result }}" >> artifact-report.md
        echo "- **ECR Security Scan:** ${{ needs.ecr-security-scan.result }}" >> artifact-report.md
        echo "- **Production Deployment:** ${{ needs.promote-and-deploy.result }}" >> artifact-report.md
        echo "" >> artifact-report.md
        
        echo "## 🔗 Artifact Links" >> artifact-report.md
        echo "- **GitHub Packages:** https://github.com/${{ github.repository }}/pkgs/container/${{ github.event.repository.name }}" >> artifact-report.md
        echo "- **AWS ECR Console:** https://${{ env.AWS_REGION }}.console.aws.amazon.com/ecr/repositories/private/${{ env.ECR_REPOSITORY }}" >> artifact-report.md
        echo "- **Application URL:** http://${{ env.EC2_IP }}:5000" >> artifact-report.md
        
        cat artifact-report.md
        
    - name: Upload Artifact Report
      uses: actions/upload-artifact@v4
      with:
        name: dual-artifact-management-report
        path: artifact-report.md
        retention-days: 30