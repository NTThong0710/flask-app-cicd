name: Flask App CI/CD with GitHub Packages & ECR Artifact Management

on:
  push:
    branches: [ master, develop ]
    tags: [ 'v*' ]
  pull_request:
    branches: [ master ]
  workflow_dispatch:

env:
  # GitHub Packages
  GITHUB_REGISTRY: ghcr.io
  GITHUB_IMAGE_NAME: ntthong0710/flask-app-cicd
  
  # AWS ECR
  AWS_REGION: ap-southeast-1
  ECR_REPOSITORY: flask-app
  
  # Deployment
  EC2_IP: 13.229.126.89

jobs:
  code-verification:
    name: Code Quality & Security Check
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.10'
        
    - name: Install code quality tools
      run: |
        python -m pip install --upgrade pip
        pip install flake8 black bandit safety mypy
        pip install -r requirements.txt || echo "No requirements.txt found"
        
    - name: Python syntax check
      run: |
        echo "ðŸ” Checking Python syntax..."
        python -m py_compile app.py
        find . -name "*.py" -exec python -m py_compile {} \;
        echo "âœ… Syntax check passed"
        
    - name: Code style check (PEP8)
      run: |
        echo "ðŸŽ¨ Checking code style with flake8..."
        flake8 . --count --select=E9,F63,F7,F82 --show-source --statistics --exclude=venv,env
        flake8 . --count --max-complexity=10 --max-line-length=120 --statistics --exclude=venv,env || true
        echo "âœ… Code style check completed"
        
    - name: Security vulnerability scan
      run: |
        echo "ðŸ”’ Scanning for security vulnerabilities..."
        bandit -r . -f json -o bandit-report.json || true
        bandit -r . --severity-level medium || echo "âš ï¸ Security warnings found"
        
    - name: Dependency security check
      run: |
        echo "ðŸ›¡ï¸ Checking dependencies for known vulnerabilities..."
        safety check || echo "âš ï¸ Dependency security warnings found"

  test:
    name: Unit Tests
    runs-on: ubuntu-latest
    needs: code-verification
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.10'
        
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt || echo "No requirements.txt found"
        pip install pytest pytest-cov
        
    - name: Run unit tests
      run: |
        if [ -f "test_app.py" ] || [ -d "tests/" ]; then
          echo "ðŸ§ª Running unit tests..."
          pytest --verbose --cov=. --cov-report=term --cov-report=xml
          echo "âœ… Tests completed"
        else
          echo "ðŸ“ Creating basic test..."
          echo "
        import requests
        import subprocess
        import time

        def test_app_starts():
            '''Test that the app can start without errors'''
            try:
                import app
                assert True
            except Exception as e:
                assert False, f'App failed to import: {e}'

        def test_basic_functionality():
            '''Basic functionality test'''
            import app
            assert hasattr(app, 'app'), 'Flask app object should exist'
                  " > basic_test.py
                  pytest basic_test.py --verbose
                fi

  sonarcloud:
    name: SonarCloud analysis
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'
      
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install pytest pytest-cov
          if [ -f requirements.txt ]; then pip install -r requirements.txt; fi
      
      - name: Run tests with coverage
        run: |
          pytest --cov=. --cov-report=xml
      
      - name: SonarCloud Scan
        uses: SonarSource/sonarcloud-github-action@master
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}

  # ===========================================
  # DUAL ARTIFACT MANAGEMENT - GITHUB PACKAGES
  # ===========================================
  
  build-and-publish-github:
    name: Build & Publish to GitHub Packages
    needs: [code-verification, test, sonarcloud]
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      id-token: write
      attestations: write
    outputs:
      image-digest: ${{ steps.build.outputs.digest }}
      image-tags: ${{ steps.meta.outputs.tags }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Extract metadata for Docker
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.GITHUB_REGISTRY }}/${{ env.GITHUB_IMAGE_NAME }}
        tags: |
          type=ref,event=tag
          type=ref,event=branch
          type=sha,prefix=sha-
          type=raw,value=latest,enable={{is_default_branch}}
        labels: |
          org.opencontainers.image.title=Flask Application
          org.opencontainers.image.description=Production Flask App with CI/CD
          org.opencontainers.image.vendor=${{ github.repository_owner }}
          org.opencontainers.image.version=${{ github.ref_name }}
          maintainer=${{ github.actor }}
          build.number=${{ github.run_number }}
          build.url=${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
    
    - name: Log in to GitHub Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.GITHUB_REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
    
    - name: Build and push to GitHub Packages
      id: build
      uses: docker/build-push-action@v5
      with:
        context: .
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        platforms: linux/amd64
        cache-from: type=gha
        cache-to: type=gha,mode=max
        provenance: true
        sbom: true
    
    - name: Generate artifact attestation
      uses: actions/attest-build-provenance@v1
      with:
        subject-name: ${{ env.GITHUB_REGISTRY }}/${{ env.GITHUB_IMAGE_NAME }}
        subject-digest: ${{ steps.build.outputs.digest }}
        push-to-registry: true

  # ===========================================
  # DUAL ARTIFACT MANAGEMENT - AWS ECR
  # ===========================================
  
  build-and-publish-ecr:
    name: Build & Push to AWS ECR
    needs: [code-verification, test, sonarcloud]
    runs-on: ubuntu-latest
    outputs:
      ecr-image-uri: ${{ steps.build-ecr.outputs.image-uri }}
      ecr-image-tag: ${{ steps.build-ecr.outputs.image-tag }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
    
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Login to Amazon ECR
      id: login-ecr
      uses: aws-actions/amazon-ecr-login@v2
    
    - name: Extract metadata for ECR
      id: meta-ecr
      run: |
        ECR_REGISTRY=${{ steps.login-ecr.outputs.registry }}
        ECR_REPOSITORY=${{ env.ECR_REPOSITORY }}
        
        # Generate tags based on git ref
        if [[ $GITHUB_REF == refs/tags/* ]]; then
          VERSION=${GITHUB_REF#refs/tags/}
          TAGS="$ECR_REGISTRY/$ECR_REPOSITORY:$VERSION,$ECR_REGISTRY/$ECR_REPOSITORY:latest"
        elif [[ $GITHUB_REF == refs/heads/master ]]; then
          TAGS="$ECR_REGISTRY/$ECR_REPOSITORY:latest,$ECR_REGISTRY/$ECR_REPOSITORY:master"
        else
          BRANCH_NAME=${GITHUB_REF#refs/heads/}
          TAGS="$ECR_REGISTRY/$ECR_REPOSITORY:$BRANCH_NAME"
        fi
        
        # Add build number tag
        TAGS="$TAGS,$ECR_REGISTRY/$ECR_REPOSITORY:build-${{ github.run_number }}"
        
        echo "tags=$TAGS" >> $GITHUB_OUTPUT
        echo "registry=$ECR_REGISTRY" >> $GITHUB_OUTPUT
        echo "repository=$ECR_REPOSITORY" >> $GITHUB_OUTPUT
    
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
    
    - name: Build and push to ECR
      id: build-ecr
      uses: docker/build-push-action@v5
      with:
        context: .
        push: true
        tags: ${{ steps.meta-ecr.outputs.tags }}
        labels: |
          org.opencontainers.image.title=Flask Application
          org.opencontainers.image.description=Production Flask App with CI/CD
          org.opencontainers.image.vendor=${{ github.repository_owner }}
          org.opencontainers.image.version=${{ github.ref_name }}
          maintainer=${{ github.actor }}
          build.number=${{ github.run_number }}
          build.url=${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          deployment.target=aws-ecr
        platforms: linux/amd64
        cache-from: type=gha
        cache-to: type=gha,mode=max
    
    - name: Set output variables
      id: outputs
      run: |
        ECR_REGISTRY=${{ steps.meta-ecr.outputs.registry }}
        ECR_REPOSITORY=${{ steps.meta-ecr.outputs.repository }}
        
        # Primary image URI for deployment
        if [[ $GITHUB_REF == refs/tags/* ]]; then
          VERSION=${GITHUB_REF#refs/tags/}
          IMAGE_URI="$ECR_REGISTRY/$ECR_REPOSITORY:$VERSION"
          IMAGE_TAG="$VERSION"
        else
          IMAGE_URI="$ECR_REGISTRY/$ECR_REPOSITORY:latest"
          IMAGE_TAG="latest"
        fi
        
        echo "image-uri=$IMAGE_URI" >> $GITHUB_OUTPUT
        echo "image-tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
        
        echo "ðŸ—ï¸ Built and pushed to ECR: $IMAGE_URI"

  # ===========================================
  # ECR SECURITY SCANNING
  # ===========================================
  
  ecr-security-scan:
    name: ECR Security Scan
    needs: build-and-publish-ecr
    runs-on: ubuntu-latest
    
    steps:
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Run ECR image scan
      run: |
        echo "ðŸ” Starting ECR security scan..."
        
        # Start image scan
        aws ecr start-image-scan \
          --repository-name ${{ env.ECR_REPOSITORY }} \
          --image-id imageTag=${{ needs.build-and-publish-ecr.outputs.ecr-image-tag }} \
          --region ${{ env.AWS_REGION }}
        
        echo "â³ Waiting for scan to complete..."
        sleep 30
        
        # Get scan results
        SCAN_RESULTS=$(aws ecr describe-image-scan-findings \
          --repository-name ${{ env.ECR_REPOSITORY }} \
          --image-id imageTag=${{ needs.build-and-publish-ecr.outputs.ecr-image-tag }} \
          --region ${{ env.AWS_REGION }} \
          --output json)
        
        echo "ðŸ“Š Scan Results:"
        echo "$SCAN_RESULTS" | jq '.imageScanFindingsSummary'
        
        # Check for critical vulnerabilities
        CRITICAL_COUNT=$(echo "$SCAN_RESULTS" | jq -r '.imageScanFindingsSummary.findingCounts.CRITICAL // 0')
        HIGH_COUNT=$(echo "$SCAN_RESULTS" | jq -r '.imageScanFindingsSummary.findingCounts.HIGH // 0')
        
        echo "ðŸš¨ Critical vulnerabilities: $CRITICAL_COUNT"
        echo "âš ï¸ High vulnerabilities: $HIGH_COUNT"
        
        if [ "$CRITICAL_COUNT" -gt 0 ]; then
          echo "âŒ Critical vulnerabilities found! Review required."
          # Don't fail the build, just warn
        fi

  # ===========================================
  # ARTIFACT PROMOTION & DEPLOYMENT
  # ===========================================
  
  promote-and-deploy:
    name: Deploy from ECR to EC2
    needs: [build-and-publish-ecr, ecr-security-scan]
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/master' || startsWith(github.ref, 'refs/tags/v')
    environment: production
    
    steps:
    - name: Configure AWS credentials
      uses: aws-actions/configure-aws-credentials@v4
      with:
        aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
        aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
        aws-region: ${{ env.AWS_REGION }}
    
    - name: Deploy to EC2 from ECR
      run: |
        echo "ðŸš€ Deploying from ECR to Production EC2..."
        
        # Install SSH client
        which ssh || (apt-get update && apt-get install -y openssh-client)
        
        # Setup SSH key
        mkdir -p ~/.ssh
        echo "${{ secrets.EC2_SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
        chmod 600 ~/.ssh/id_rsa
        
        # Add EC2 to known_hosts
        ssh-keyscan -H ${{ env.EC2_IP }} >> ~/.ssh/known_hosts
        
        # Get ECR image URI
        ECR_IMAGE_URI="${{ needs.build-and-publish-ecr.outputs.ecr-image-uri }}"
        
        echo "ðŸ“¦ Deploying image: $ECR_IMAGE_URI"
        
        # Deploy to EC2
        ssh -i ~/.ssh/id_rsa ec2-user@${{ env.EC2_IP }} << EOF
          # Configure AWS CLI on EC2 (if not already configured)
          export AWS_DEFAULT_REGION=${{ env.AWS_REGION }}
          
          # Login to ECR
          aws ecr get-login-password --region ${{ env.AWS_REGION }} | docker login --username AWS --password-stdin ${{ needs.build-and-publish-ecr.outputs.ecr-image-uri-base }}
          
          echo "ðŸ“¦ Pulling image from ECR: $ECR_IMAGE_URI"
          docker pull $ECR_IMAGE_URI
          
          echo "ðŸ’¾ Creating backup of current container"
          docker tag flask-app:current flask-app:backup-\$(date +%Y%m%d-%H%M%S) 2>/dev/null || true
          
          echo "ðŸ”„ Updating application..."
          docker stop flask-app 2>/dev/null || true
          docker rm flask-app 2>/dev/null || true
          
          echo "ðŸ†• Starting new container from ECR..."
          docker run -d \
            --name flask-app \
            --restart unless-stopped \
            -p 5000:5000 \
            --label "version=${{ github.ref_name }}" \
            --label "build.number=${{ github.run_number }}" \
            --label "deployed.at=\$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
            --label "source=aws-ecr" \
            $ECR_IMAGE_URI
          
          # Health check
          echo "ðŸ¥ Performing health check..."
          sleep 15
          
          if curl -f http://localhost:5000/health 2>/dev/null || curl -f http://localhost:5000/ 2>/dev/null; then
            echo "âœ… Health check passed"
            docker tag $ECR_IMAGE_URI flask-app:current
            
            # Cleanup old backup images (keep last 3)
            docker images --format "table {{.Repository}}:{{.Tag}}\t{{.CreatedAt}}" | grep flask-app:backup | tail -n +4 | cut -f1 | xargs -r docker rmi || true
          else
            echo "âŒ Health check failed, rolling back..."
            docker stop flask-app 2>/dev/null || true
            docker rm flask-app 2>/dev/null || true
            
            # Rollback to backup if exists
            BACKUP_IMAGE=\$(docker images --format "{{.Repository}}:{{.Tag}}" flask-app:backup-* | head -1)
            if [ ! -z "\$BACKUP_IMAGE" ]; then
              docker run -d --name flask-app --restart unless-stopped -p 5000:5000 \$BACKUP_IMAGE
              echo "ðŸ”™ Rolled back to: \$BACKUP_IMAGE"
            fi
            exit 1
          fi
          
          echo "ðŸ§¹ Cleaning up unused images..."
          docker image prune -f
          
          echo "ðŸŽ‰ ECR Deployment completed successfully!"
          echo "ðŸ“ Application URL: http://${{ env.EC2_IP }}:5000"
          echo "ðŸ·ï¸ Deployed Image: $ECR_IMAGE_URI"
        EOF

  # ===========================================
  # ARTIFACT MANAGEMENT REPORTING
  # ===========================================
  
  artifact-report:
    name: Generate Dual Artifact Management Report
    needs: [build-and-publish-github, build-and-publish-ecr, ecr-security-scan, promote-and-deploy]
    runs-on: ubuntu-latest
    if: always()
    permissions:
      packages: read
    
    steps:
    - name: Generate Comprehensive Artifact Report
      run: |
        echo "# ðŸ“‹ Dual Artifact Management Report" > artifact-report.md
        echo "" >> artifact-report.md
        echo "**Build Information:**" >> artifact-report.md
        echo "- Build Number: ${{ github.run_number }}" >> artifact-report.md
        echo "- Git Reference: ${{ github.ref }}" >> artifact-report.md
        echo "- Commit SHA: ${{ github.sha }}" >> artifact-report.md
        echo "- Build Time: $(date -u)" >> artifact-report.md
        echo "" >> artifact-report.md
        
        echo "## ðŸ“¦ GitHub Packages Artifacts" >> artifact-report.md
        echo '```' >> artifact-report.md
        echo '${{ needs.build-and-publish-github.outputs.image-tags }}' >> artifact-report.md
        echo '```' >> artifact-report.md
        echo "" >> artifact-report.md
        
        echo "## ðŸ—ï¸ AWS ECR Artifacts" >> artifact-report.md
        echo "- **ECR Image URI:** \`${{ needs.build-and-publish-ecr.outputs.ecr-image-uri }}\`" >> artifact-report.md
        echo "- **ECR Image Tag:** \`${{ needs.build-and-publish-ecr.outputs.ecr-image-tag }}\`" >> artifact-report.md
        echo "" >> artifact-report.md
        
        echo "## ðŸ“Š Pipeline Results" >> artifact-report.md
        echo "- **GitHub Packages Build:** ${{ needs.build-and-publish-github.result }}" >> artifact-report.md
        echo "- **ECR Build:** ${{ needs.build-and-publish-ecr.result }}" >> artifact-report.md
        echo "- **ECR Security Scan:** ${{ needs.ecr-security-scan.result }}" >> artifact-report.md
        echo "- **Production Deployment:** ${{ needs.promote-and-deploy.result }}" >> artifact-report.md
        echo "" >> artifact-report.md
        
        echo "## ðŸ”— Artifact Links" >> artifact-report.md
        echo "- **GitHub Packages:** https://github.com/${{ github.repository }}/pkgs/container/${{ github.event.repository.name }}" >> artifact-report.md
        echo "- **AWS ECR Console:** https://${{ env.AWS_REGION }}.console.aws.amazon.com/ecr/repositories/private/${{ env.ECR_REPOSITORY }}" >> artifact-report.md
        echo "- **Application URL:** http://${{ env.EC2_IP }}:5000" >> artifact-report.md
        
        cat artifact-report.md
        
    - name: Upload Artifact Report
      uses: actions/upload-artifact@v4
      with:
        name: dual-artifact-management-report
        path: artifact-report.md
        retention-days: 30